# 第一章：SOD框架概述与设计理念

## 1.1 SOD框架简介

### 1.1.1 什么是SOD框架

SOD框架（**S**QL-MAP、**O**RM、**D**ata Controls）是一个拥有超过15年历史的国产开源企业级数据应用开发框架。它诞生于2006年，最初名为PDF.NET框架，后来发展演变为SOD框架。框架的名字来源于其三大核心功能模块的英文首字母缩写：

- **S** - SQL-MAP：基于XML配置的SQL查询和数据访问层映射
- **O** - ORM：对象关系映射，包含独特的OQL查询语言
- **D** - Data Controls：数据窗体控件，支持WebForm/WinForm/WPF

SOD框架的设计目标是实现对数据访问细节的全方位掌控能力，它不仅仅是一个ORM框架，而是一个完整的企业级数据开发解决方案。

### 1.1.2 框架的发展历程

```
2006年 - PDF.NET框架诞生
   ↓
2008年 - 发布首个公开版本，支持.NET 2.0
   ↓
2010年 - 引入SQL-MAP技术，实现SQL语句与代码的分离
   ↓
2012年 - 发明OQL（ORM Query Language）查询语言
   ↓
2015年 - 框架重命名为SOD，开源发布
   ↓
2020年 - 支持.NET Core和.NET 5
   ↓
2024年 - 全面支持.NET 6/7/8，国产化数据库深度适配
```

### 1.1.3 框架的定位

SOD框架特别适合以下类型的企业项目：

1. **金融行业**：对数据操作安全有严格要求的项目
2. **互联网行业**：对数据访问速度、内存和CPU资源有苛刻要求的项目
3. **快速迭代项目**：需求常常变化，要求快速开发上线的项目
4. **企业级应用**：对稳定性要求高，需要长期维护的MIS、ERP、MES等系统
5. **中小团队**：预算有限的初创企业或中小型项目
6. **国产化项目**：需要支持国产数据库（人大金仓、达梦等）的项目

## 1.2 核心设计理念

### 1.2.1 简单与效率的平衡

SOD框架追求的核心目标是**简单与效率的平衡**，这体现在以下三个方面：

#### 代码的精简

```csharp
// 传统ADO.NET方式查询用户
string sql = "SELECT * FROM User WHERE ID=@ID";
using(var conn = new SqlConnection(connStr))
{
    conn.Open();
    using(var cmd = new SqlCommand(sql, conn))
    {
        cmd.Parameters.AddWithValue("@ID", 1);
        using(var reader = cmd.ExecuteReader())
        {
            if(reader.Read())
            {
                var user = new User();
                user.ID = reader.GetInt32(0);
                user.Name = reader.GetString(1);
                // ... 更多字段映射
            }
        }
    }
}

// SOD框架方式查询用户
User user = new User() { ID = 1 };
var result = OQL.From(user).Select().Where(user.ID).END.ToObject();
```

#### 开发维护的简单

SOD框架的设计让初级程序员也能轻松看懂每一行代码，同时让资深程序员拥有"越野驾驶"般的掌控感。

#### 追求极致的运行效率

框架在运行时尽量减少反射调用，采用动态编译和缓存技术，确保数据访问的高性能。

### 1.2.2 约定优于配置

SOD框架遵循"约定优于配置"的原则：

```csharp
// 接口类型 IDbUser 默认映射到表 DbUser（去掉前缀I）
public interface IDbUser
{
    int ID { get; set; }
    string Name { get; set; }
}

// 动态创建实体类，无需显式配置
IDbUser user = EntityBuilder.CreateEntity<IDbUser>();
```

如果遵循框架的约定，可以大大简化配置和代码量。

### 1.2.3 动态元数据映射

与传统ORM框架使用静态特性（Attribute）进行映射不同，SOD框架采用**动态元数据映射**：

```csharp
public class UserEntity : EntityBase
{
    public UserEntity()
    {
        // 元数据在运行时定义，可动态修改
        TableName = "TbUser";           // 表名
        IdentityName = "ID";            // 标识字段
        PrimaryKeys.Add("ID");          // 主键
    }
    
    // 属性与字段的映射也是动态的
    public int ID
    {
        get { return getProperty<int>("ID"); }
        set { setProperty("ID", value); }
    }
}
```

这种动态性带来的优势：

1. **分表分库支持**：可以在运行时修改表名，轻松实现分表分库
2. **虚拟主键**：主键可以是逻辑上的，不必与物理主键一致
3. **灵活的字段映射**：属性名和字段名可以不同
4. **简化配置**：不依赖.NET特性声明

### 1.2.4 多模式数据开发

SOD框架提供三种数据开发模式，开发者可以根据场景选择最合适的模式：

#### SQL开发模式（SQL-MAP）

适用于：复杂SQL查询、性能敏感场景、DBA维护的SQL

```xml
<Select CommandName="GetUsers" Description="查询用户">
    <![CDATA[
    SELECT * FROM User WHERE Status=#Status:Int32#
    ]]>
</Select>
```

#### ORM开发模式（OQL）

适用于：常规CRUD操作、快速开发、类型安全的查询

```csharp
var users = OQL.From(user)
    .Select()
    .Where(cmp => cmp.Property(user.Status) == 1)
    .OrderBy(user.CreateTime)
    .END
    .ToList();
```

#### 窗体控件开发模式（Data Controls）

适用于：表单数据绑定、快速原型开发

```csharp
// 一行代码实现表单数据收集
DataFormHelper.CollectData(user, this.Controls);
// 一行代码实现表单数据填充
DataFormHelper.FillData(user, this.Controls);
```

### 1.2.5 充血实体类模型

SOD框架采用"充血实体类"模型，实体类不仅仅是数据容器，还能追踪属性变化状态：

```csharp
public class UserEntity : EntityBase
{
    public string Name
    {
        get { return getProperty<string>("Name"); }
        set { setProperty("Name", value, 50); }  // 50是字段长度
    }
}

// 使用示例
UserEntity user = new UserEntity();
user.Name = "张三";  // 此时框架记录了Name属性已被修改

// 更新时只更新修改过的字段
EntityQuery<UserEntity>.Instance.Update(user, db);
// 生成的SQL：UPDATE TbUser SET Name=@Name WHERE ID=@ID
```

充血实体类的优势：

1. **精确更新**：只更新修改过的字段
2. **状态追踪**：知道哪些字段被修改
3. **自动回填**：插入后自动获取自增ID

## 1.3 框架架构概览

### 1.3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        应用层 (Application Layer)                │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │  SQL-MAP     │  │    ORM/OQL   │  │   Data Controls      │  │
│  │  SQL查询映射  │  │  对象关系映射 │  │   数据窗体控件       │  │
│  └──────────────┘  └──────────────┘  └──────────────────────┘  │
├─────────────────────────────────────────────────────────────────┤
│                      核心层 (Core Layer)                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │ EntityBase   │  │ EntityQuery  │  │   EntityContainer    │  │
│  │ 实体类基类    │  │ 实体查询器   │  │   数据容器           │  │
│  └──────────────┘  └──────────────┘  └──────────────────────┘  │
├─────────────────────────────────────────────────────────────────┤
│                    数据访问层 (Data Access Layer)                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                     AdoHelper                             │  │
│  │            抽象数据访问辅助类（数据库无关）                   │  │
│  └──────────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────────────┤
│                   数据提供程序 (Data Providers)                   │
│  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────────┐   │
│  │SqlServer│ │ MySQL  │ │ Oracle │ │SQLite  │ │达梦/金仓...│   │
│  └────────┘ └────────┘ └────────┘ └────────┘ └────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 1.3.2 核心程序集

| 程序集 | 说明 |
|--------|------|
| PWMIS.Core | 框架核心类库，包含所有核心功能 |
| PWMIS.Core.Extensions | 框架扩展方法和GOQL支持 |
| PWMIS.Windows | Windows窗体数据控件 |
| PWMIS.Web | Web窗体数据控件 |

### 1.3.3 主要命名空间

```csharp
PWMIS.DataMap.Entity     // 实体类相关
PWMIS.DataMap.SqlMap     // SQL-MAP相关
PWMIS.DataProvider.Data  // 数据提供程序
PWMIS.Common             // 公共工具类
PWMIS.Core               // 核心扩展
```

## 1.4 与其他ORM框架的对比

### 1.4.1 SOD vs Entity Framework

| 特性 | SOD | Entity Framework |
|------|-----|-----------------|
| 学习曲线 | 低 | 较高 |
| 运行时性能 | 高 | 中等 |
| 批量更新 | 简单直接 | 复杂 |
| SQL控制 | 完全可控 | 有限 |
| 动态映射 | 支持 | 不支持 |
| 分表分库 | 内置支持 | 需要扩展 |
| .NET版本 | 2.0起 | 3.5起 |
| 国产数据库 | 良好支持 | 有限 |

### 1.4.2 SOD vs Dapper

| 特性 | SOD | Dapper |
|------|-----|--------|
| ORM功能 | 完整 | 基础 |
| 查询语言 | OQL | 纯SQL |
| 实体状态追踪 | 支持 | 不支持 |
| Code First | 支持 | 不支持 |
| 数据窗体 | 支持 | 不支持 |
| 企业级解决方案 | 丰富 | 无 |

### 1.4.3 SOD vs NHibernate

| 特性 | SOD | NHibernate |
|------|-----|------------|
| 配置复杂度 | 低 | 高 |
| 性能 | 高 | 中等 |
| 动态性 | 强 | 弱 |
| 中文文档 | 丰富 | 较少 |
| 社区活跃度 | 中 | 中 |

## 1.5 框架的核心优势

### 1.5.1 安全性

SOD框架将数据访问安全作为最重要的目标：

1. **全面的参数化查询**：所有数据库都支持参数化查询，防止SQL注入
2. **抽象SQL参数**：统一的参数语法，屏蔽不同数据库的差异
3. **查询日志**：完整记录SQL执行过程，便于审计

### 1.5.2 灵活性

1. **多种开发模式**：SQL-MAP、ORM、Data Controls
2. **动态映射**：运行时可修改元数据
3. **多数据库支持**：一套代码适配多种数据库

### 1.5.3 高性能

1. **精确SQL生成**：只查询/更新需要的字段
2. **缓存机制**：支持热缓存
3. **命令管道**：批量操作优化
4. **微型ORM模式**：直接操作DataReader

### 1.5.4 易用性

1. **简单API**：几乎没有学习成本
2. **链式语法**：OQL的链式调用
3. **约定优于配置**：减少配置工作
4. **集成开发工具**：实体类生成器、SQL-MAP代码生成器

## 1.6 适用场景与技术选型建议

### 1.6.1 推荐使用SOD的场景

✅ 需要同时支持多种数据库的项目  
✅ 对SQL有精细控制需求的项目  
✅ 需要快速开发的中小型项目  
✅ 需要支持国产数据库的项目  
✅ 团队.NET技能参差不齐的项目  
✅ 需要长期维护的企业级系统  

### 1.6.2 可能不适合的场景

⚠️ 已经深度使用EF的大型遗留系统  
⚠️ 纯微服务架构且查询极其简单的项目  
⚠️ 需要完整EF生态系统支持的项目  

### 1.6.3 技术选型建议

```
项目类型判断
    │
    ├── 简单查询、性能极致 → Dapper
    │
    ├── 复杂ORM、生态需求 → Entity Framework
    │
    ├── 多数据库、精细控制、快速开发 → SOD
    │
    └── 企业级、国产化、全功能 → SOD
```

## 1.7 本章小结

SOD框架是一个历经15年实战检验的国产开源数据开发框架，它的设计理念体现了对简单性和效率的平衡追求。通过SQL-MAP、ORM和Data Controls三大核心功能，SOD为开发者提供了全方位的数据开发解决方案。

框架的核心优势包括：
- 动态元数据映射，灵活适应各种场景
- 多种开发模式，满足不同需求
- 充血实体类，精确控制数据操作
- 优秀的安全性和性能
- 良好的国产化支持

在接下来的章节中，我们将深入学习SOD框架的各个组成部分，掌握框架的使用方法和最佳实践。

---

> **下一章预告**：第二章将详细介绍SOD框架的架构设计和核心组件，深入理解AdoHelper、EntityBase、OQL等核心类的实现原理。

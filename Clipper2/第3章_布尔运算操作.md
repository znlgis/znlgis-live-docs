# 第三章 布尔运算操作

## 3.1 引言

布尔运算是Clipper2最核心的功能之一，它允许我们对多边形进行交集、并集、差集和异或等操作。这些操作在计算机图形学、CAD设计、GIS分析等领域有着广泛的应用。本章将深入介绍Clipper2中布尔运算的原理、使用方法和最佳实践。

## 3.2 布尔运算的基本概念

### 3.2.1 什么是布尔运算

布尔运算源自数学中的集合论，用于组合两个或多个几何形状。在二维几何中，布尔运算主要包括四种基本操作：

**交集（Intersection）**

交集运算返回两个多边形的重叠区域。只有同时属于两个输入多边形的点才会出现在结果中。

数学表示：A ∩ B

应用场景：
- 计算两个区域的公共部分
- 视野裁剪
- 碰撞检测的精确区域

**并集（Union）**

并集运算将两个多边形合并为一个，得到它们的完整覆盖区域。

数学表示：A ∪ B

应用场景：
- 合并相邻区域
- 创建复合形状
- 地块合并

**差集（Difference）**

差集运算从第一个多边形中减去第二个多边形的区域。

数学表示：A - B 或 A \ B

应用场景：
- 从形状中切除区域
- 创建孔洞
- 遮罩效果

**异或（XOR）**

异或运算返回两个多边形不重叠的区域，即只属于其中一个多边形的部分。

数学表示：A ⊕ B 或 (A ∪ B) - (A ∩ B)

应用场景：
- 检测变化区域
- 创建环形效果
- 对称差运算

### 3.2.2 主体与裁剪

在Clipper2中，参与布尔运算的多边形被分为两类：

**主体（Subject）**：布尔运算的主要对象，差集运算中被减去的一方

**裁剪（Clip）**：用于与主体进行运算的多边形，差集运算中作为"刀"的一方

```cpp
Paths64 subject;  // 主体多边形
subject.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));

Paths64 clip;     // 裁剪多边形
clip.push_back(MakePath({50, 50, 150, 50, 150, 150, 50, 150}));

// 对于交集、并集、异或，subject和clip的顺序不影响结果
// 对于差集，subject - clip 和 clip - subject 的结果不同
```

### 3.2.3 填充规则的作用

填充规则决定了多边形的哪些区域被认为是"内部"。这对于处理自交多边形和复杂的嵌套结构至关重要。

Clipper2支持四种填充规则：

```cpp
enum class FillRule { 
    EvenOdd,   // 偶奇规则
    NonZero,   // 非零规则
    Positive,  // 正数规则
    Negative   // 负数规则
};
```

详细的填充规则说明请参见第一章。

## 3.3 使用简化API进行布尔运算

Clipper2提供了一组简化的静态函数，可以用一行代码完成布尔运算。

### 3.3.1 交集运算

```cpp
// C++
#include "clipper2/clipper.h"
using namespace Clipper2Lib;

int main() {
    // 创建两个相交的正方形
    Paths64 subject;
    subject.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));
    
    Paths64 clip;
    clip.push_back(MakePath({50, 50, 150, 50, 150, 150, 50, 150}));
    
    // 执行交集运算
    Paths64 result = Intersect(subject, clip, FillRule::NonZero);
    
    // result 包含一个50x50的正方形：(50,50) → (100,50) → (100,100) → (50,100)
    
    return 0;
}
```

```csharp
// C#
using Clipper2Lib;

class Program
{
    static void Main()
    {
        Paths64 subject = new Paths64();
        subject.Add(Clipper.MakePath(new long[] { 0, 0, 100, 0, 100, 100, 0, 100 }));
        
        Paths64 clip = new Paths64();
        clip.Add(Clipper.MakePath(new long[] { 50, 50, 150, 50, 150, 150, 50, 150 }));
        
        Paths64 result = Clipper.Intersect(subject, clip, FillRule.NonZero);
    }
}
```

### 3.3.2 并集运算

```cpp
// 合并两个正方形
Paths64 subject;
subject.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));

Paths64 clip;
clip.push_back(MakePath({50, 50, 150, 50, 150, 150, 50, 150}));

Paths64 result = Union(subject, clip, FillRule::NonZero);
// result 包含一个L形多边形，覆盖两个正方形的区域
```

**单一集合的并集**

对于只有主体多边形（没有裁剪多边形）的情况，Union函数可以用于：
- 合并重叠的多边形
- 简化自交多边形
- 分解复杂多边形为简单多边形

```cpp
// 合并多个重叠的圆形近似多边形
Paths64 circles;
circles.push_back(MakeCircle(Point64(0, 0), 50));
circles.push_back(MakeCircle(Point64(40, 0), 50));
circles.push_back(MakeCircle(Point64(80, 0), 50));

// 使用单参数版本的Union
Paths64 merged = Union(circles, FillRule::NonZero);
```

### 3.3.3 差集运算

```cpp
// 从大正方形中减去小正方形
Paths64 subject;
subject.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));

Paths64 clip;
clip.push_back(MakePath({25, 25, 75, 25, 75, 75, 25, 75}));

Paths64 result = Difference(subject, clip, FillRule::NonZero);
// result 包含一个带有中心孔洞的正方形

// 注意：差集运算的顺序很重要
// subject - clip ≠ clip - subject
Paths64 result2 = Difference(clip, subject, FillRule::NonZero);
// result2 是空的，因为clip完全在subject内部
```

### 3.3.4 异或运算

```cpp
// 两个部分重叠的正方形进行异或运算
Paths64 subject;
subject.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));

Paths64 clip;
clip.push_back(MakePath({50, 50, 150, 50, 150, 150, 50, 150}));

Paths64 result = Xor(subject, clip, FillRule::NonZero);
// result 包含两个L形区域
```

### 3.3.5 使用浮点数坐标

对于浮点数坐标，可以使用PathsD类型：

```cpp
// 使用浮点数坐标
PathsD subject;
subject.push_back(MakePathD({0.0, 0.0, 10.5, 0.0, 10.5, 10.5, 0.0, 10.5}));

PathsD clip;
clip.push_back(MakePathD({5.25, 5.25, 15.75, 5.25, 15.75, 15.75, 5.25, 15.75}));

// 第四个参数指定精度（小数位数）
PathsD result = Intersect(subject, clip, FillRule::NonZero, 2);
```

## 3.4 使用Clipper类进行高级控制

对于需要更多控制的场景，可以使用Clipper64或ClipperD类。

### 3.4.1 Clipper64类

```cpp
#include "clipper2/clipper.h"
using namespace Clipper2Lib;

int main() {
    Clipper64 clipper;
    
    // 添加主体多边形
    Paths64 subject;
    subject.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));
    clipper.AddSubject(subject);
    
    // 添加裁剪多边形
    Paths64 clip;
    clip.push_back(MakePath({50, 50, 150, 50, 150, 150, 50, 150}));
    clipper.AddClip(clip);
    
    // 执行布尔运算
    Paths64 result;
    clipper.Execute(ClipType::Intersection, FillRule::NonZero, result);
    
    return 0;
}
```

### 3.4.2 ClipType枚举

```cpp
enum class ClipType {
    None,
    Intersection,
    Union,
    Difference,
    Xor
};
```

### 3.4.3 添加开放路径

除了闭合的多边形，Clipper2还支持开放的折线：

```cpp
Clipper64 clipper;

// 添加闭合的主体多边形
Paths64 subject;
subject.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));
clipper.AddSubject(subject);

// 添加开放的主体折线
Paths64 subjectOpen;
subjectOpen.push_back(MakePath({0, 50, 150, 50}));  // 一条水平线
clipper.AddOpenSubject(subjectOpen);

// 添加裁剪多边形
Paths64 clip;
clip.push_back(MakePath({25, 25, 75, 25, 75, 75, 25, 75}));
clipper.AddClip(clip);

// 执行运算并分别获取闭合和开放结果
Paths64 closedResult;
Paths64 openResult;
clipper.Execute(ClipType::Difference, FillRule::NonZero, closedResult, openResult);
// closedResult 包含裁剪后的多边形
// openResult 包含裁剪后的折线
```

### 3.4.4 使用PolyTree输出

当需要保留多边形的层次结构时，使用PolyTree输出：

```cpp
Clipper64 clipper;
clipper.AddSubject(subject);
clipper.AddClip(clip);

// 使用PolyTree输出
PolyTree64 tree;
Paths64 openPaths;
clipper.Execute(ClipType::Intersection, FillRule::NonZero, tree, openPaths);

// 遍历PolyTree获取层次结构
for (auto child = tree.begin(); child != tree.end(); ++child) {
    if (!(*child)->IsHole()) {
        // 这是一个外边界多边形
        Path64 exterior = (*child)->Polygon();
        
        // 获取其孔洞
        for (auto hole = (*child)->begin(); hole != (*child)->end(); ++hole) {
            Path64 holePath = (*hole)->Polygon();
        }
    }
}
```

### 3.4.5 复用Clipper对象

在循环中复用Clipper对象可以提高性能：

```cpp
Clipper64 clipper;

for (int i = 0; i < 1000; i++) {
    // 清空之前的数据，但保留已分配的内存
    clipper.Clear();
    
    // 添加新的多边形
    clipper.AddSubject(GetSubject(i));
    clipper.AddClip(GetClip(i));
    
    // 执行运算
    Paths64 result;
    clipper.Execute(ClipType::Intersection, FillRule::NonZero, result);
    
    ProcessResult(result);
}
```

## 3.5 处理复杂多边形

### 3.5.1 带孔洞的多边形

```cpp
// 创建一个带孔洞的多边形
Paths64 subject;
// 外边界（逆时针方向）
subject.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));
// 孔洞（顺时针方向）
subject.push_back(MakePath({25, 25, 25, 75, 75, 75, 75, 25}));

// 裁剪多边形
Paths64 clip;
clip.push_back(MakePath({50, 0, 150, 0, 150, 100, 50, 100}));

// 执行交集运算
Paths64 result = Intersect(subject, clip, FillRule::NonZero);
// 结果会正确处理孔洞
```

### 3.5.2 自交多边形

自交多边形是指边界与自身相交的多边形。不同的填充规则会产生不同的结果：

```cpp
// 创建一个8字形的自交多边形
Paths64 figure8;
figure8.push_back(MakePath({0, 0, 100, 100, 100, 0, 0, 100}));

// 使用NonZero规则 - 两个半部分都被填充
Paths64 resultNonZero = Union(figure8, FillRule::NonZero);

// 使用EvenOdd规则 - 中间交叉点处会有孔洞
Paths64 resultEvenOdd = Union(figure8, FillRule::EvenOdd);
```

### 3.5.3 多个分离的多边形

```cpp
// 主体包含多个分离的多边形
Paths64 subject;
subject.push_back(MakePath({0, 0, 50, 0, 50, 50, 0, 50}));
subject.push_back(MakePath({100, 0, 150, 0, 150, 50, 100, 50}));
subject.push_back(MakePath({200, 0, 250, 0, 250, 50, 200, 50}));

// 裁剪多边形跨越多个主体
Paths64 clip;
clip.push_back(MakePath({25, -25, 225, -25, 225, 75, 25, 75}));

// 交集运算会正确处理每个主体
Paths64 result = Intersect(subject, clip, FillRule::NonZero);
// result 包含3个多边形
```

### 3.5.4 重叠的边

当两个多边形有共享的边时，Clipper2能够正确处理：

```cpp
// 两个共享一条边的正方形
Paths64 subject;
subject.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));

Paths64 clip;
clip.push_back(MakePath({100, 0, 200, 0, 200, 100, 100, 100}));
// clip的左边与subject的右边重合

// 并集运算会正确合并它们
Paths64 result = Union(subject, clip, FillRule::NonZero);
// result 是一个200x100的矩形
```

## 3.6 布尔运算的性能优化

### 3.6.1 减少顶点数量

顶点数量是影响性能的主要因素。可以使用路径简化来减少顶点：

```cpp
// 在布尔运算前简化路径
Paths64 simplified = SimplifyPaths(complexPaths, 2.0);
Paths64 result = Intersect(simplified, clip, FillRule::NonZero);
```

### 3.6.2 使用矩形裁剪

当裁剪区域是矩形时，使用专门的RectClip函数：

```cpp
// 常规布尔运算裁剪
Paths64 clipPolygon;
clipPolygon.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));
Paths64 result1 = Intersect(subject, clipPolygon, FillRule::NonZero);

// 使用优化的矩形裁剪
Rect64 clipRect(0, 0, 100, 100);
Paths64 result2 = RectClip(clipRect, subject);
// result2 与 result1 相同，但速度更快
```

### 3.6.3 批量处理

对于大量相同裁剪区域的操作，可以复用Clipper对象：

```cpp
Clipper64 clipper;
clipper.AddClip(clip);  // 只添加一次裁剪区域

for (const auto& subject : subjects) {
    clipper.Clear();
    clipper.AddClip(clip);  // 重新添加裁剪区域
    clipper.AddSubject(subject);
    
    Paths64 result;
    clipper.Execute(ClipType::Intersection, FillRule::NonZero, result);
}
```

### 3.6.4 多线程处理

Clipper2的Clipper对象不是线程安全的，但可以在不同线程中使用不同的Clipper实例：

```cpp
#include <thread>
#include <vector>

void ProcessBatch(const std::vector<Paths64>& subjects, 
                  const Paths64& clip, 
                  std::vector<Paths64>& results) {
    Clipper64 clipper;  // 每个线程有自己的Clipper实例
    
    for (size_t i = 0; i < subjects.size(); i++) {
        clipper.Clear();
        clipper.AddSubject(subjects[i]);
        clipper.AddClip(clip);
        clipper.Execute(ClipType::Intersection, FillRule::NonZero, results[i]);
    }
}

int main() {
    // 将工作分成多个批次，每个线程处理一批
    std::vector<std::thread> threads;
    
    for (int t = 0; t < numThreads; t++) {
        threads.emplace_back(ProcessBatch, 
                            std::ref(subjectBatches[t]),
                            std::ref(clip),
                            std::ref(resultBatches[t]));
    }
    
    for (auto& thread : threads) {
        thread.join();
    }
    
    return 0;
}
```

## 3.7 布尔运算的常见问题

### 3.7.1 结果为空

**问题**：执行布尔运算后结果为空。

**可能的原因**：
1. 两个多边形不相交（对于交集运算）
2. 多边形的方向不正确
3. 坐标精度问题

**解决方法**：

```cpp
// 检查多边形是否有效
bool valid = !subject.empty() && !clip.empty();

// 检查边界框是否相交
Rect64 subjectBounds = Bounds(subject);
Rect64 clipBounds = Bounds(clip);
bool mayIntersect = subjectBounds.Intersects(clipBounds);

// 确保多边形方向正确
for (auto& path : subject) {
    if (!IsPositive(path)) {
        std::reverse(path.begin(), path.end());
    }
}
```

### 3.7.2 意外的孔洞

**问题**：并集运算后出现意外的孔洞。

**原因**：填充规则与多边形方向不匹配。

**解决方法**：

```cpp
// 使用EvenOdd规则时，方向不重要
Paths64 result = Union(paths, FillRule::EvenOdd);

// 或者使用NonZero规则并确保方向一致
for (auto& path : paths) {
    if (!IsPositive(path)) {
        std::reverse(path.begin(), path.end());
    }
}
Paths64 result = Union(paths, FillRule::NonZero);
```

### 3.7.3 自交多边形的处理

**问题**：自交多边形产生意外的结果。

**解决方法**：

```cpp
// 方法1：使用Union简化自交多边形
Paths64 simplified = Union(selfIntersecting, FillRule::NonZero);

// 方法2：先检测并报告自交
bool hasSelfIntersection = false;
for (const auto& path : paths) {
    // 检查每条边是否与其他边相交
    for (size_t i = 0; i < path.size(); i++) {
        for (size_t j = i + 2; j < path.size(); j++) {
            if (j == path.size() - 1 && i == 0) continue;
            if (SegmentsIntersect(path[i], path[i+1], path[j], path[(j+1) % path.size()])) {
                hasSelfIntersection = true;
                break;
            }
        }
    }
}
```

### 3.7.4 精度损失

**问题**：浮点数转换导致精度损失。

**解决方法**：

```cpp
// 使用足够大的缩放因子
const double scale = 1000000.0;  // 6位小数精度

// 手动缩放
Paths64 scaledSubject = ScalePaths<int64_t, double>(subjectD, scale);
Paths64 scaledClip = ScalePaths<int64_t, double>(clipD, scale);

Paths64 result = Intersect(scaledSubject, scaledClip, FillRule::NonZero);

// 缩放回原始尺寸
PathsD resultD = ScalePaths<double, int64_t>(result, 1.0 / scale);
```

## 3.8 实际应用示例

### 3.8.1 创建复合形状

```cpp
// 创建一个复合形状：圆形减去星形
Paths64 circle;
circle.push_back(MakeCircle(Point64(100, 100), 80));

Paths64 star;
star.push_back(MakeStar(Point64(100, 100), 60, 30, 5));

Paths64 result = Difference(circle, star, FillRule::NonZero);
// result 是一个圆形，中心有星形孔洞
```

### 3.8.2 区域合并

```cpp
// 合并多个重叠的区域
Paths64 regions;
regions.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));
regions.push_back(MakePath({80, 0, 180, 0, 180, 100, 80, 100}));
regions.push_back(MakePath({160, 0, 260, 0, 260, 100, 160, 100}));

Paths64 merged = Union(regions, FillRule::NonZero);
// merged 是一个连续的区域
```

### 3.8.3 遮罩裁剪

```cpp
// 使用遮罩裁剪图像区域
Paths64 image;
image.push_back(MakePath({0, 0, 800, 0, 800, 600, 0, 600}));

Paths64 mask;
mask.push_back(MakePath({100, 100, 700, 100, 700, 500, 100, 500}));
// 添加一个孔洞
mask.push_back(MakePath({200, 200, 200, 400, 600, 400, 600, 200}));

Paths64 result = Intersect(image, mask, FillRule::NonZero);
// result 是带有中心孔洞的遮罩区域
```

### 3.8.4 地块拆分

```cpp
// 用一条线将地块拆分为两部分
Paths64 parcel;
parcel.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));

// 创建一个非常薄的矩形作为分割线
Paths64 splitLine;
splitLine.push_back(MakePath({50, -10, 51, -10, 51, 110, 50, 110}));

// 左半部分
Paths64 left = Difference(parcel, splitLine, FillRule::NonZero);
left = Intersect(left, MakePath({-10, -10, 50, -10, 50, 110, -10, 110}), FillRule::NonZero);

// 右半部分
Paths64 rightClip;
rightClip.push_back(MakePath({51, -10, 110, -10, 110, 110, 51, 110}));
Paths64 right = Intersect(parcel, rightClip, FillRule::NonZero);
```

### 3.8.5 碰撞区域计算

```cpp
// 计算两个移动物体的碰撞区域
Paths64 objectA = GetObjectBounds(positionA);
Paths64 objectB = GetObjectBounds(positionB);

Paths64 collision = Intersect(objectA, objectB, FillRule::NonZero);
if (!collision.empty()) {
    // 发生碰撞
    double collisionArea = Area(collision);
    // 根据碰撞面积决定反应
}
```

## 3.9 与其他库的比较

### 3.9.1 与JTS/GEOS的比较

| 特性 | Clipper2 | JTS/GEOS |
|------|----------|----------|
| 精度 | 整数运算，精确 | 浮点运算，可能有误差 |
| 性能 | 非常快 | 较快 |
| 鲁棒性 | 极佳 | 良好 |
| 拓扑处理 | 需要后处理 | 内置 |
| 曲线支持 | 无 | 有 |

### 3.9.2 与CGAL的比较

| 特性 | Clipper2 | CGAL |
|------|----------|------|
| 学习曲线 | 简单 | 陡峭 |
| 依赖 | 无 | 多 |
| 精度 | 64位整数 | 任意精度 |
| 功能范围 | 2D多边形 | 全面的几何库 |
| 许可证 | Boost | 双许可 |

## 3.10 算法原理简介

Clipper2使用改进的Vatti算法进行布尔运算。这里简要介绍其工作原理。

### 3.10.1 扫描线算法

Vatti算法是一种扫描线算法。它通过一条水平扫描线从下向上扫过所有的多边形，在扫描过程中维护当前扫描线与多边形边的交点。

```
          y
          ↑
          |     ┌────────┐
          |     │        │
扫描线 ───┼─────┼────────┼───→
          |     │   ∩    │
          |  ┌──┴────────┴──┐
          |  │              │
          └──┴──────────────┴────→ x
```

### 3.10.2 事件处理

算法在以下事件点进行处理：
- **顶点事件**：扫描线遇到多边形顶点
- **交点事件**：两条边相交

### 3.10.3 活动边列表

算法维护一个"活动边列表"（Active Edge List），包含当前与扫描线相交的所有边。随着扫描线移动，边被添加或移除。

```cpp
// 伪代码示意
while (!eventQueue.empty()) {
    Event event = eventQueue.pop();
    
    if (event.type == EventType::Vertex) {
        // 处理顶点事件
        UpdateActiveEdges(event.vertex);
    }
    else if (event.type == EventType::Intersection) {
        // 处理交点事件
        SwapEdges(event.edge1, event.edge2);
    }
    
    // 根据填充规则和裁剪类型决定输出
    DetermineOutput(activeEdges, clipType, fillRule);
}
```

## 3.11 本章小结

本章我们深入学习了Clipper2的布尔运算功能：

1. **基本概念**：交集、并集、差集、异或四种运算类型
2. **简化API**：Intersect、Union、Difference、Xor函数
3. **Clipper类**：Clipper64和ClipperD提供更多控制选项
4. **复杂多边形处理**：孔洞、自交、重叠边的处理
5. **性能优化**：路径简化、矩形裁剪、批量处理、多线程
6. **常见问题**：结果为空、意外孔洞、自交处理、精度损失
7. **实际应用**：复合形状、区域合并、遮罩裁剪等

在下一章中，我们将学习Clipper2的另一个核心功能——多边形偏移操作。


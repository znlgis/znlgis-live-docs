# 第二章 Clipper2核心数据结构

## 2.1 引言

在使用Clipper2进行几何运算之前，深入理解其核心数据结构是非常必要的。Clipper2的数据结构设计精巧而高效，它们构成了整个库的基础。本章将详细介绍Point（点）、Path（路径）、Paths（路径集合）、Rect（矩形）以及PolyTree（多边形树）等核心数据结构，并探讨它们的使用方法和最佳实践。

## 2.2 点（Point）结构

点是最基本的几何元素，Clipper2提供了两种点类型来满足不同的需求。

### 2.2.1 Point64结构

Point64是Clipper2的核心点类型，使用64位有符号整数存储坐标值。

**C++定义**

```cpp
struct Point64 {
    int64_t x;
    int64_t y;
    
    Point64() : x(0), y(0) {}
    Point64(int64_t x, int64_t y) : x(x), y(y) {}
    
    // 运算符重载
    bool operator==(const Point64& other) const;
    bool operator!=(const Point64& other) const;
    Point64 operator+(const Point64& other) const;
    Point64 operator-(const Point64& other) const;
    Point64 operator-() const;  // 取反
};
```

**C#定义**

```csharp
public struct Point64
{
    public long X;
    public long Y;
    
    public Point64(long x, long y)
    {
        X = x;
        Y = y;
    }
    
    public Point64(double x, double y)
    {
        X = (long)Math.Round(x);
        Y = (long)Math.Round(y);
    }
}
```

**基本使用**

```cpp
// C++示例
Point64 p1(100, 200);
Point64 p2(300, 400);

// 点的加法
Point64 sum = p1 + p2;  // (400, 600)

// 点的减法
Point64 diff = p2 - p1;  // (200, 200)

// 判断相等
bool equal = (p1 == p2);  // false

// 取反
Point64 neg = -p1;  // (-100, -200)
```

### 2.2.2 PointD结构

PointD使用双精度浮点数存储坐标，适用于需要浮点数精度的场景。

**C++定义**

```cpp
struct PointD {
    double x;
    double y;
    
    PointD() : x(0), y(0) {}
    PointD(double x, double y) : x(x), y(y) {}
    PointD(const Point64& pt) : x(static_cast<double>(pt.x)), 
                                 y(static_cast<double>(pt.y)) {}
};
```

**使用示例**

```cpp
// C++示例
PointD pd1(10.5, 20.3);
PointD pd2(30.7, 40.9);

// 从整数点转换
Point64 intPt(100, 200);
PointD fromInt(intPt);  // (100.0, 200.0)
```

### 2.2.3 点的运算与辅助函数

Clipper2提供了丰富的点运算函数：

**距离计算**

```cpp
// 计算两点之间的欧几里得距离
double dist = Distance(Point64(0, 0), Point64(3, 4));  // 5.0

// 计算两点之间的平方距离（避免开方运算，更快）
double sqDist = DistanceSqr(Point64(0, 0), Point64(3, 4));  // 25.0
```

**点与线的关系**

```cpp
// 判断点与有向线段的位置关系
// 返回值 > 0：点在线段左侧
// 返回值 < 0：点在线段右侧
// 返回值 = 0：点在线段上
double cross = CrossProduct(Point64(0, 0), Point64(10, 0), Point64(5, 5));
// cross > 0，点(5,5)在线段(0,0)→(10,0)的左侧

// 判断三点是否共线
bool collinear = IsCollinear(Point64(0, 0), Point64(5, 5), Point64(10, 10));
// true
```

**点与多边形的关系**

```cpp
// 判断点是否在多边形内部
Path64 polygon = MakePath({0, 0, 100, 0, 100, 100, 0, 100});
PointInPolygonResult result = PointInPolygon(Point64(50, 50), polygon);
// result = PointInPolygonResult::IsInside

// 可能的返回值：
// IsInside  - 点在多边形内部
// IsOutside - 点在多边形外部
// IsOn      - 点在多边形边界上
```

### 2.2.4 带Z值的点（可选功能）

当启用USINGZ编译选项时，Point64结构会包含一个额外的Z分量：

```cpp
// 需要定义 CLIPPER2_USINGZ 宏
struct Point64 {
    int64_t x;
    int64_t y;
    int64_t z;  // Z值，仅在启用USINGZ时可用
    
    Point64(int64_t x, int64_t y, int64_t z = 0) 
        : x(x), y(y), z(z) {}
};
```

Z值的主要用途：
- 存储原始顶点的索引或ID
- 在3D应用中传递高程信息
- 传递自定义的顶点属性

```cpp
// 创建带Z值的点
Point64 pt(100, 200, 42);  // x=100, y=200, z=42

// Z值会在裁剪过程中被插值
// 可以通过回调函数自定义Z值的计算方式
```

## 2.3 路径（Path）结构

路径是一系列有序点的集合，可以表示一个多边形的边界或一条折线。

### 2.3.1 Path64类型

Path64是Point64的向量（动态数组）。

**C++定义**

```cpp
using Path64 = std::vector<Point64>;
```

**C#定义**

```csharp
public class Path64 : List<Point64>
{
    public Path64() : base() { }
    public Path64(int capacity) : base(capacity) { }
    public Path64(IEnumerable<Point64> path) : base(path) { }
}
```

**创建路径**

```cpp
// C++：方式一 - 使用MakePath辅助函数
Path64 path1 = MakePath({0, 0, 100, 0, 100, 100, 0, 100});
// 创建一个正方形：(0,0) → (100,0) → (100,100) → (0,100)

// C++：方式二 - 逐个添加点
Path64 path2;
path2.push_back(Point64(0, 0));
path2.push_back(Point64(100, 0));
path2.push_back(Point64(100, 100));
path2.push_back(Point64(0, 100));

// C++：方式三 - 使用初始化列表
Path64 path3 = {
    Point64(0, 0),
    Point64(100, 0),
    Point64(100, 100),
    Point64(0, 100)
};
```

```csharp
// C#：方式一 - 使用MakePath
Path64 path1 = Clipper.MakePath(new long[] { 0, 0, 100, 0, 100, 100, 0, 100 });

// C#：方式二 - 逐个添加
Path64 path2 = new Path64();
path2.Add(new Point64(0, 0));
path2.Add(new Point64(100, 0));
path2.Add(new Point64(100, 100));
path2.Add(new Point64(0, 100));

// C#：方式三 - 使用集合初始化器
Path64 path3 = new Path64
{
    new Point64(0, 0),
    new Point64(100, 0),
    new Point64(100, 100),
    new Point64(0, 100)
};
```

### 2.3.2 PathD类型

PathD使用PointD类型，适用于浮点数坐标：

```cpp
using PathD = std::vector<PointD>;

// 创建浮点数路径
PathD pathD = MakePathD({0.0, 0.0, 10.5, 0.0, 10.5, 10.5, 0.0, 10.5});
```

### 2.3.3 路径方向（Orientation）

多边形路径的顶点顺序决定了其方向，这在某些填充规则下非常重要。

**判断路径方向**

```cpp
// 判断路径是否为正方向（逆时针）
Path64 path = MakePath({0, 0, 100, 0, 100, 100, 0, 100});
bool isPositive = IsPositive(path);  // true（逆时针）

// 注意：这是在标准数学坐标系下的定义
// 如果Y轴向下（如屏幕坐标系），方向会相反
```

**反转路径方向**

```cpp
// 反转路径中点的顺序
Path64 reversed = ReversePath(path);
// 原路径：(0,0) → (100,0) → (100,100) → (0,100)
// 反转后：(0,100) → (100,100) → (100,0) → (0,0)
```

### 2.3.4 路径的几何属性

**面积计算**

```cpp
// 计算多边形面积
Path64 square = MakePath({0, 0, 100, 0, 100, 100, 0, 100});
double area = Area(square);  // 10000.0

// 面积的符号表示方向：
// 正值 - 逆时针（正方向）
// 负值 - 顺时针（负方向）
```

**边界框计算**

```cpp
// 获取路径的轴对齐边界框
Path64 path = MakePath({10, 20, 50, 30, 40, 80, 15, 60});
Rect64 bounds = Bounds(path);
// bounds.left = 10, bounds.top = 20
// bounds.right = 50, bounds.bottom = 80
```

**周长计算**

```cpp
// 计算路径的周长
Path64 square = MakePath({0, 0, 100, 0, 100, 100, 0, 100});
double perimeter = Perimeter(square, true);  // true表示闭合路径
// 结果：400.0
```

### 2.3.5 路径简化与处理

**去除重复点**

```cpp
// 去除路径中的连续重复点
Path64 pathWithDups = MakePath({0, 0, 0, 0, 100, 0, 100, 0, 100, 100});
Path64 cleaned = StripDuplicates(pathWithDups, false);
// 结果：{(0,0), (100,0), (100,100)}
// 第二个参数表示是否为闭合路径
```

**简化路径（Douglas-Peucker算法）**

```cpp
// 使用给定的容差简化路径
Path64 complexPath = ...;  // 包含很多点的复杂路径
PathD simplified = SimplifyPath(PathD(complexPath), 2.0, false);
// 容差为2.0，非闭合路径
// 这会移除对整体形状影响很小的点
```

**剥离共线点**

```cpp
// 移除路径中位于同一直线上的中间点
Path64 path = MakePath({0, 0, 50, 0, 100, 0, 100, 100});
Path64 result = StripCollinear(path, false);
// 结果：{(0,0), (100,0), (100,100)}
// 点(50,0)被移除，因为它在(0,0)和(100,0)的连线上
```

### 2.3.6 路径的坐标转换

**缩放**

```cpp
// 缩放路径坐标
Path64 path = MakePath({0, 0, 100, 0, 100, 100, 0, 100});
Path64 scaled = ScalePath(path, 2.0);  // 放大2倍
// 结果：{(0,0), (200,0), (200,200), (0,200)}

// 使用不同的X和Y缩放因子
Path64 stretched = ScalePath(path, 2.0, 1.5);
// X方向放大2倍，Y方向放大1.5倍
```

**平移**

```cpp
// 平移路径
Path64 path = MakePath({0, 0, 100, 0, 100, 100, 0, 100});
Path64 translated = TranslatePath(path, 50, 50);
// 结果：{(50,50), (150,50), (150,150), (50,150)}
```

**Path64与PathD之间的转换**

```cpp
// 从Path64转换为PathD
Path64 path64 = MakePath({0, 0, 100, 0, 100, 100});
PathD pathD = Path64ToPathD(path64);

// 从PathD转换为Path64
PathD pathD2 = MakePathD({0.5, 0.5, 100.5, 0.5, 100.5, 100.5});
Path64 path64_2 = PathDToPath64(pathD2);
// 浮点数会四舍五入为整数
```

## 2.4 路径集合（Paths）结构

Paths是Path的集合，可以表示多个独立的多边形，也可以表示一个带有孔洞的复杂多边形。

### 2.4.1 Paths64类型

```cpp
using Paths64 = std::vector<Path64>;
```

```csharp
public class Paths64 : List<Path64>
{
    public Paths64() : base() { }
    public Paths64(int capacity) : base(capacity) { }
    public Paths64(IEnumerable<Path64> paths) : base(paths) { }
}
```

### 2.4.2 创建Paths

```cpp
// C++：创建包含多个多边形的Paths
Paths64 paths;
paths.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));  // 第一个多边形
paths.push_back(MakePath({200, 0, 300, 0, 300, 100, 200, 100}));  // 第二个多边形

// 创建带孔洞的多边形
Paths64 polygonWithHole;
// 外边界（逆时针）
polygonWithHole.push_back(MakePath({0, 0, 100, 0, 100, 100, 0, 100}));
// 孔洞（顺时针）
polygonWithHole.push_back(MakePath({25, 25, 25, 75, 75, 75, 75, 25}));
```

```csharp
// C#
Paths64 paths = new Paths64();
paths.Add(Clipper.MakePath(new long[] { 0, 0, 100, 0, 100, 100, 0, 100 }));
paths.Add(Clipper.MakePath(new long[] { 200, 0, 300, 0, 300, 100, 200, 100 }));
```

### 2.4.3 Paths的几何属性

**计算总面积**

```cpp
// 计算所有路径的总面积
Paths64 paths = ...;
double totalArea = Area(paths);
// 如果包含孔洞（顺时针路径），它们的面积会被减去
```

**获取边界框**

```cpp
// 获取所有路径的总边界框
Paths64 paths = ...;
Rect64 bounds = Bounds(paths);
```

### 2.4.4 Paths的转换

```cpp
// 缩放所有路径
Paths64 paths = ...;
Paths64 scaled = ScalePaths(paths, 2.0);

// 平移所有路径
Paths64 translated = TranslatePaths(paths, 100, 100);

// Paths64与PathsD之间的转换
Paths64 paths64 = ...;
PathsD pathsD = Paths64ToPathsD(paths64);

PathsD pathsD2 = ...;
Paths64 paths64_2 = PathsDToPaths64(pathsD2);
```

### 2.4.5 扁平化处理

有时需要将嵌套的路径结构扁平化为简单的路径集合：

```cpp
// 将PolyTree转换为Paths（后面会详细介绍PolyTree）
PolyTree64 tree = ...;
Paths64 paths = PolyTreeToPaths64(tree);
```

## 2.5 矩形（Rect）结构

矩形是一种特殊的多边形，在裁剪操作中经常使用。Clipper2提供了专门的矩形类型和优化的矩形裁剪算法。

### 2.5.1 Rect64类型

```cpp
struct Rect64 {
    int64_t left;
    int64_t top;
    int64_t right;
    int64_t bottom;
    
    Rect64() : left(0), top(0), right(0), bottom(0) {}
    Rect64(int64_t l, int64_t t, int64_t r, int64_t b)
        : left(l), top(t), right(r), bottom(b) {}
    
    // 常用方法
    int64_t Width() const { return right - left; }
    int64_t Height() const { return bottom - top; }
    Point64 MidPoint() const;
    bool IsEmpty() const { return bottom <= top || right <= left; }
    bool Contains(const Point64& pt) const;
    bool Contains(const Rect64& other) const;
    bool Intersects(const Rect64& other) const;
};
```

### 2.5.2 RectD类型

```cpp
struct RectD {
    double left;
    double top;
    double right;
    double bottom;
    
    // 与Rect64类似的接口
    double Width() const;
    double Height() const;
    PointD MidPoint() const;
    bool IsEmpty() const;
    bool Contains(const PointD& pt) const;
    bool Contains(const RectD& other) const;
    bool Intersects(const RectD& other) const;
};
```

### 2.5.3 矩形操作

```cpp
// 创建矩形
Rect64 rect1(0, 0, 100, 100);
Rect64 rect2(50, 50, 150, 150);

// 获取属性
int64_t width = rect1.Width();    // 100
int64_t height = rect1.Height();  // 100
Point64 center = rect1.MidPoint();  // (50, 50)

// 判断是否为空
bool empty = rect1.IsEmpty();  // false

// 判断点是否在矩形内
bool contains = rect1.Contains(Point64(50, 50));  // true

// 判断矩形是否相交
bool intersects = rect1.Intersects(rect2);  // true

// 使用Bounds函数获取路径的边界矩形
Path64 path = MakePath({10, 20, 50, 30, 40, 80, 15, 60});
Rect64 bounds = Bounds(path);
```

### 2.5.4 矩形裁剪

Clipper2提供了专门优化的矩形裁剪函数，性能优于通用的布尔运算：

```cpp
// 使用矩形裁剪多边形
Rect64 clipRect(0, 0, 100, 100);
Paths64 paths = ...;  // 要裁剪的多边形

// 裁剪闭合多边形
Paths64 result = RectClip(clipRect, paths);

// 裁剪开放折线
Paths64 openPaths = ...;
Paths64 clippedLines = RectClipLines(clipRect, openPaths);
```

## 2.6 多边形树（PolyTree）结构

PolyTree是Clipper2中最复杂的数据结构，它以树形结构表示嵌套的多边形层次关系。

### 2.6.1 为什么需要PolyTree

在很多实际应用中，多边形之间存在嵌套关系：
- 一个外边界包含多个孔洞
- 孔洞内部可能又包含岛屿
- 岛屿内部可能还有孔洞...

Paths结构只是一个简单的路径列表，无法表达这种层次关系。PolyTree则以树形结构清晰地表示这些关系。

### 2.6.2 PolyPath结构

PolyPath是PolyTree中的节点类型：

```cpp
class PolyPath64 {
public:
    // 获取父节点
    PolyPath64* Parent() const;
    
    // 判断是否为孔洞
    bool IsHole() const;
    
    // 获取多边形数据
    const Path64& Polygon() const;
    
    // 获取子节点数量
    size_t ChildCount() const;
    
    // 获取子节点
    PolyPath64* Child(size_t index) const;
    
    // 获取子节点迭代器
    PolyPath64Iterator begin() const;
    PolyPath64Iterator end() const;
    
    // 计算面积
    double Area() const;
};
```

### 2.6.3 PolyTree结构

PolyTree是一个特殊的PolyPath，作为整棵树的根节点：

```cpp
class PolyTree64 : public PolyPath64 {
public:
    // 清空树
    void Clear();
    
    // 设置反转（Y轴方向）
    void SetInvertY(bool value);
};
```

### 2.6.4 使用PolyTree

**在布尔运算中使用PolyTree输出**

```cpp
// 使用Clipper64类进行布尔运算并输出PolyTree
Clipper64 clipper;
clipper.AddSubject(subjectPaths);
clipper.AddClip(clipPaths);

PolyTree64 tree;
Paths64 openPaths;  // 开放路径输出（如果有的话）
clipper.Execute(ClipType::Intersection, FillRule::NonZero, tree, openPaths);
```

**遍历PolyTree**

```cpp
// 递归遍历PolyTree
void TraversePolyTree(const PolyPath64* node, int depth = 0) {
    // 打印缩进
    for (int i = 0; i < depth; i++) std::cout << "  ";
    
    // 打印节点信息
    if (node->IsHole()) {
        std::cout << "孔洞, ";
    } else {
        std::cout << "多边形, ";
    }
    std::cout << "顶点数: " << node->Polygon().size();
    std::cout << ", 面积: " << node->Area() << std::endl;
    
    // 遍历子节点
    for (auto child = node->begin(); child != node->end(); ++child) {
        TraversePolyTree(*child, depth + 1);
    }
}

// 使用
PolyTree64 tree = ...;
for (auto child = tree.begin(); child != tree.end(); ++child) {
    TraversePolyTree(*child, 0);
}
```

**示例输出**

```
多边形, 顶点数: 4, 面积: 10000
  孔洞, 顶点数: 4, 面积: -2500
    多边形, 顶点数: 4, 面积: 625
多边形, 顶点数: 4, 面积: 5000
```

这表示：
- 第一个外边界多边形（面积10000）
  - 包含一个孔洞（面积-2500，负号表示孔洞）
    - 孔洞内有一个岛屿（面积625）
- 第二个独立的外边界多边形（面积5000）

### 2.6.5 PolyTree与Paths的转换

```cpp
// 将PolyTree转换为Paths（丢失层次信息）
PolyTree64 tree = ...;
Paths64 paths = PolyTreeToPaths64(tree);

// 如果只想获取外边界（不包括孔洞内的岛屿）
// 需要自定义遍历逻辑
Paths64 outerBoundaries;
for (auto child = tree.begin(); child != tree.end(); ++child) {
    if (!(*child)->IsHole()) {
        outerBoundaries.push_back((*child)->Polygon());
    }
}
```

### 2.6.6 判断多边形层次

```cpp
// 判断一个路径是否为孔洞取决于其在树中的深度
// 深度为偶数（0, 2, 4...）- 外边界
// 深度为奇数（1, 3, 5...）- 孔洞

void ClassifyPaths(const PolyPath64* node, 
                   Paths64& exteriors, 
                   Paths64& holes,
                   int depth = 0) {
    if (!node->Polygon().empty()) {
        if (depth % 2 == 0) {
            exteriors.push_back(node->Polygon());
        } else {
            holes.push_back(node->Polygon());
        }
    }
    
    for (auto child = node->begin(); child != node->end(); ++child) {
        ClassifyPaths(*child, exteriors, holes, depth + 1);
    }
}
```

## 2.7 PathType枚举

PathType枚举用于在Clipper类中指定路径的类型。

```cpp
enum class PathType { Subject, Clip };
```

- **Subject**：主体路径，参与布尔运算的第一个操作数
- **Clip**：裁剪路径，参与布尔运算的第二个操作数

```cpp
Clipper64 clipper;
clipper.AddPath(path1, PathType::Subject);
clipper.AddPath(path2, PathType::Clip);
// 或者使用便捷方法
clipper.AddSubject(path1);
clipper.AddClip(path2);
```

## 2.8 数据结构的内存管理

### 2.8.1 C++中的内存管理

Clipper2的C++版本使用标准库容器（std::vector），遵循RAII原则，内存会自动管理。

```cpp
{
    Paths64 paths;
    paths.push_back(MakePath({0, 0, 100, 0, 100, 100}));
    // 使用paths...
}  // paths在这里自动销毁，内存自动释放
```

**避免不必要的复制**

```cpp
// 使用引用避免复制
void ProcessPaths(const Paths64& paths) {
    // ...
}

// 使用移动语义
Paths64 CreatePaths() {
    Paths64 result;
    result.push_back(...);
    return result;  // 返回值优化(RVO)或移动语义
}
```

### 2.8.2 C#中的内存管理

C#版本使用托管内存，由垃圾回收器自动管理。

```csharp
Paths64 paths = new Paths64();
paths.Add(Clipper.MakePath(...));
// 不需要手动释放内存
```

### 2.8.3 性能建议

**预分配容量**

```cpp
// 如果知道大概的点数，预分配可以减少内存重分配
Path64 path;
path.reserve(1000);  // 预分配1000个点的空间
for (int i = 0; i < 1000; i++) {
    path.push_back(Point64(i, i));
}
```

**复用对象**

```cpp
// 在循环中复用Clipper对象
Clipper64 clipper;
for (int i = 0; i < 100; i++) {
    clipper.Clear();  // 清空，但保留已分配的内存
    clipper.AddSubject(...);
    clipper.AddClip(...);
    Paths64 result;
    clipper.Execute(..., result);
}
```

## 2.9 类型别名与兼容性

### 2.9.1 类型别名

```cpp
// Clipper2中定义的类型别名
using Point64 = Point<int64_t>;
using PointD = Point<double>;
using Path64 = Path<int64_t>;
using PathD = Path<double>;
using Paths64 = Paths<int64_t>;
using PathsD = Paths<double>;
using Rect64 = Rect<int64_t>;
using RectD = Rect<double>;
```

### 2.9.2 自定义点类型的适配

如果你的应用已有自己的点类型，可以通过转换函数适配：

```cpp
// 假设你的点类型
struct MyPoint {
    float x, y;
};

// 转换为Path64
Path64 ConvertToPath64(const std::vector<MyPoint>& myPoints, double scale) {
    Path64 path;
    path.reserve(myPoints.size());
    for (const auto& p : myPoints) {
        path.push_back(Point64(
            static_cast<int64_t>(p.x * scale),
            static_cast<int64_t>(p.y * scale)
        ));
    }
    return path;
}

// 从Path64转换回来
std::vector<MyPoint> ConvertFromPath64(const Path64& path, double scale) {
    std::vector<MyPoint> result;
    result.reserve(path.size());
    for (const auto& p : path) {
        result.push_back({
            static_cast<float>(p.x / scale),
            static_cast<float>(p.y / scale)
        });
    }
    return result;
}
```

## 2.10 实用工具函数

Clipper2提供了许多实用的工具函数：

### 2.10.1 路径检验

```cpp
// 检查路径是否有效
bool IsValid(const Path64& path);

// 检查Paths是否有效
bool IsValid(const Paths64& paths);
```

### 2.10.2 方向调整

```cpp
// 确保外边界为正方向（逆时针），孔洞为负方向（顺时针）
Paths64 EnsureOrientation(const Paths64& paths, bool isOuter);
```

### 2.10.3 几何计算

```cpp
// 计算两条线段的交点
bool GetIntersectPoint(
    const Point64& ln1a, const Point64& ln1b,
    const Point64& ln2a, const Point64& ln2b,
    PointD& ip);

// 计算点到线段的最近点
Point64 NearestPoint(const Point64& pt, const Path64& path);

// 计算点到路径的距离
double PerpendicularDistance(const Point64& pt, 
                             const Point64& line1, 
                             const Point64& line2);
```

## 2.11 本章小结

本章我们深入学习了Clipper2的核心数据结构：

1. **Point（点）**：Point64使用整数坐标，PointD使用浮点坐标，支持基本运算和几何判断
2. **Path（路径）**：有序点的集合，表示多边形边界或折线
3. **Paths（路径集合）**：多个路径的集合，可表示多个多边形或带孔洞的复杂多边形
4. **Rect（矩形）**：轴对齐矩形，用于边界框和优化裁剪
5. **PolyTree（多边形树）**：树形结构，表示嵌套多边形的层次关系

理解这些数据结构是使用Clipper2的基础。在下一章中，我们将学习如何使用这些数据结构进行布尔运算操作。

